<!DOCTYPE html>
<html lang="da">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Netvaerk</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000;
        }
        canvas { 
            display: block; 
        }
        #cameraFeed {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            opacity: 0;
            z-index: -1;
        }
    </style>
</head>
<body>
    <video id="cameraFeed" autoplay playsinline></video>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const noiseGen = new SimplexNoise();

        // Skab kaotisk 3D-væsen
        const particleCount = 1000;
        const particles = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const connections = [];

        for (let i = 0; i < particleCount; i++) {
            positions[i * 3] = (Math.random() - 0.5) * 10;
            positions[i * 3 + 1] = (Math.random() - 0.5) * 10;
            positions[i * 3 + 2] = (Math.random() - 0.5) * 10;
        }

        particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        const particleMaterial = new THREE.PointsMaterial({
            color: 0xFFFFFF,
            size: 0.1,
            blending: THREE.AdditiveBlending,
            transparent: true,
            opacity: 0.8
        });

        const particleSystem = new THREE.Points(particles, particleMaterial);
        scene.add(particleSystem);

        // Skab forbindelser mellem partikler
        for (let i = 0; i < particleCount; i++) {
            for (let j = i + 1; j < particleCount; j++) {
                if (Math.random() < 0.01) {
                    connections.push([i, j]);
                }
            }
        }

        const lineMaterial = new THREE.LineBasicMaterial({ 
            color: 0xFFFFFF, 
            transparent: true, 
            opacity: 0.3 
        });
        const lineGeometry = new THREE.BufferGeometry();
        const linePositions = new Float32Array(connections.length * 6);
        lineGeometry.setAttribute('position', new THREE.BufferAttribute(linePositions, 3));
        const lineSystem = new THREE.LineSegments(lineGeometry, lineMaterial);
        scene.add(lineSystem);

        camera.position.z = 15;

        let motionIntensity = 0;
        let motionDirection = new THREE.Vector2(0, 0);

        const video = document.getElementById('cameraFeed');
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        let lastImageData;

        navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } })
            .then(stream => {
                video.srcObject = stream;
                video.onloadedmetadata = () => {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                };
            })
            .catch(err => console.error("Fejl ved adgang til kamera:", err));

        function detectMotion() {
            if (video.readyState === video.HAVE_ENOUGH_DATA) {
                ctx.drawImage(video, 0, 0);
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                
                if (lastImageData) {
                    let diffX = 0, diffY = 0, totalDiff = 0;
                    for (let y = 0; y < canvas.height; y++) {
                        for (let x = 0; x < canvas.width; x++) {
                            const i = (y * canvas.width + x) * 4;
                            const diff = Math.abs(imageData.data[i] - lastImageData.data[i]);
                            diffX += diff * (x / canvas.width - 0.5);
                            diffY += diff * (y / canvas.height - 0.5);
                            totalDiff += diff;
                        }
                    }
                    motionIntensity = Math.min(totalDiff / (imageData.data.length / 4) / 50, 1);
                    motionDirection.set(diffX / totalDiff, -diffY / totalDiff);
                }
                
                lastImageData = imageData;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            detectMotion();

            const time = Date.now() * 0.001;
            const positions = particles.attributes.position.array;

            for (let i = 0; i < particleCount; i++) {
                const ix = i * 3;
                const iy = i * 3 + 1;
                const iz = i * 3 + 2;

                // Kaotisk bevægelse
                positions[ix] += Math.sin(time + i) * 0.01 + motionDirection.x * motionIntensity * 0.1;
                positions[iy] += Math.cos(time + i * 1.1) * 0.01 + motionDirection.y * motionIntensity * 0.1;
                positions[iz] += Math.sin(time * 1.1 + i * 1.2) * 0.01;

                // Begræns positioner
                positions[ix] = Math.max(Math.min(positions[ix], 5), -5);
                positions[iy] = Math.max(Math.min(positions[iy], 5), -5);
                positions[iz] = Math.max(Math.min(positions[iz], 5), -5);

                // Tilføj noise-baseret bevægelse
                const noiseValue = noiseGen.noise3D(positions[ix] * 0.1, positions[iy] * 0.1, time * 0.5) * motionIntensity;
                positions[ix] += noiseValue * 0.1;
                positions[iy] += noiseValue * 0.1;
                positions[iz] += noiseValue * 0.1;
            }

            particles.attributes.position.needsUpdate = true;

            // Opdater forbindelser
            for (let i = 0; i < connections.length; i++) {
                const [a, b] = connections[i];
                const ax = positions[a * 3], ay = positions[a * 3 + 1], az = positions[a * 3 + 2];
                const bx = positions[b * 3], by = positions[b * 3 + 1], bz = positions[b * 3 + 2];
                linePositions[i * 6] = ax;
                linePositions[i * 6 + 1] = ay;
                linePositions[i * 6 + 2] = az;
                linePositions[i * 6 + 3] = bx;
                linePositions[i * 6 + 4] = by;
                linePositions[i * 6 + 5] = bz;
            }

            lineSystem.geometry.attributes.position.needsUpdate = true;

            // Rotér væsenet baseret på bevægelse
            particleSystem.rotation.x += motionDirection.y * motionIntensity * 0.05;
            particleSystem.rotation.y += motionDirection.x * motionIntensity * 0.05;
            lineSystem.rotation.copy(particleSystem.rotation);

            // Pulserende effekt
            const scale = 1 + Math.sin(time * 2) * 0.1 * motionIntensity;
            particleSystem.scale.set(scale, scale, scale);
            lineSystem.scale.copy(particleSystem.scale);

            renderer.render(scene, camera);
        }

        animate();

        // Fuldskærm funktionalitet
        function toggleFullScreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }

        document.addEventListener('click', toggleFullScreen);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
